name: Docker Hub CI and Deploy on Release
run-name: Deploy ${{ github.ref_name }}

on:
  # This workflow will ONLY run when a tag is pushed.
  # Pull requests are handled by a separate, simpler workflow if needed.
  push:
    tags:
      - 'v*.*.*' # Recommended: Use a 'v' prefix for version tags, e.g., v1.2.0
      - '*.*.*'  # Also supports tags without a 'v', e.g., 1.2.0

jobs:
  build-and-push: # Renamed for clarity
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image to Docker Hub
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.aws
          push: true
          # This correctly uses the Git tag (e.g., "v1.2.0") as the Docker tag
          tags: ${{ secrets.DOCKER_USERNAME }}/${{ github.event.repository.name }}:${{ github.ref_name }}

  deploy-to-ecs:
    runs-on: ubuntu-latest
    # This job depends on the build job finishing successfully
    needs: build-and-push
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ca-central-1 # <-- IMPORTANT: Change to your AWS region

      - name: Deploy to Amazon ECS
        run: |
          # Set your variables
          CLUSTER_NAME="btap-app4-dev-cluster"
          SERVICE_NAME="btap-app4-dev-service"
          TASK_FAMILY="btap-app4-dev-task"

          # This directly and reliably gets the tag that triggered the workflow (e.g., "1.1.4")
          NEW_IMAGE_URI="${{ secrets.DOCKER_USERNAME }}/${{ github.event.repository.name }}:${{ github.ref_name }}"

          echo "Deploying new image to ECS: $NEW_IMAGE_URI"
          
          # 1. Get the current task definition and save it to a file.
          # This is more robust than using a shell variable.
          aws ecs describe-task-definition --task-definition $TASK_FAMILY > task-definition.json

          # 2. Create a new definition file.
          # This jq command filters the '.taskDefinition' object, updates the image,
          # and removes ALL keys that are invalid for registration.
            jq --arg IMAGE_URI "$NEW_IMAGE_URI" \
            --arg COGNITO_REGION "${{ secrets.COGNITO_REGION }}" \
            --arg COGNITO_USER_POOL_ID "${{ secrets.COGNITO_USER_POOL_ID }}" \
            --arg COGNITO_APP_CLIENT_ID "${{ secrets.COGNITO_APP_CLIENT_ID }}" \
            --arg COGNITO_APP_PUBLIC_CLIENT_ID "${{ secrets.COGNITO_APP_PUBLIC_CLIENT_ID }}" \
            --arg COGNITO_APP_CLIENT_SECRET "${{ secrets.COGNITO_APP_CLIENT_SECRET }}" \
            --arg COGNITO_DOMAIN "${{ secrets.COGNITO_DOMAIN }}" \
            --arg APP_BASE_URL "${{ secrets.APP_BASE_URL }}" \
            --arg VERSION_STRING "${{ secrets.VERSION_STRING }}" \
            '.taskDefinition
            | .containerDefinitions[0].image = $IMAGE_URI
            | .containerDefinitions[0].environment += [
                {name: "COGNITO_REGION", value: $COGNITO_REGION},
                {name: "COGNITO_USER_POOL_ID", value: $COGNITO_USER_POOL_ID},
                {name: "COGNITO_APP_CLIENT_ID", value: $COGNITO_APP_CLIENT_ID},
                {name: "COGNITO_APP_PUBLIC_CLIENT_ID", value: $COGNITO_APP_PUBLIC_CLIENT_ID},
                {name: "COGNTO_APP_CLIENT_SECRET", value: $COGNITO_APP_CLIENT_SECRET},
                {name: "COGNITO_DOMAIN", value: $COGNITO_DOMAIN},
                {name: "APP_BASE_URL", value: $APP_BASE_URL},
                {name: "VERSION_STRING", value: $VERSION_STRING}
            ]
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .tags)
            ' task-definition.json > new-task-definition.json
          
          # 3. Register the new task definition using the clean file.
          # The 'file://' prefix is the standard way to pass JSON input.
          # It avoids issues with shell quoting and special characters.
          NEW_TASK_INFO=$(aws ecs register-task-definition --cli-input-json file://new-task-definition.json)
          NEW_REVISION_ARN=$(echo $NEW_TASK_INFO | jq -r '.taskDefinition.taskDefinitionArn')

          # 4. Update the service to use the new task definition revision.
          echo "Updating ECS service to use new revision: $NEW_REVISION_ARN"
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $NEW_REVISION_ARN \
            --force-new-deployment
          
          echo "Deployment initiated successfully."